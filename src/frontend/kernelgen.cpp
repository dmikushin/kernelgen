/*
 * KernelGen - the LLVM-based compiler with GPU kernels generation over C backend.
 *
 * Copyright (c) 2011 Dmitry Mikushin
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising 
 * from the use of this software.
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it freely,
 * subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented;
 * you must not claim that you wrote the original software.
 * If you use this software in a product, an acknowledgment
 * in the product documentation would be appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such,
 * and must not be misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

#include "execute.h"

#include <cstdarg>
#include <cstdio>
#include <malloc.h>

// Construct the command line from the specified format
// and parameter list.
static int build_command(const char* fmt, char** cmd, ...)
{
	if (!cmd || !fmt) return 0;
	va_list list;
	va_start(list, cmd);
	int length = vsnprintf(NULL, 0, fmt, list);
	va_end(list);
	if (length < 0) return 1;
	*cmd = (char*)malloc(length + 1);
	va_start(list, cmd);
	vsprintf(*cmd, fmt, list);
	va_end(list);
	return 0;
}

#include "llvm/Instructions.h"
#include "llvm/LLVMContext.h"
#include "llvm/Module.h"
#include "llvm/PassManager.h"
#include "llvm/Support/CallSite.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/IRReader.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/TypeBuilder.h"
#include "llvm/Target/TargetData.h"
#include "llvm/Transforms/IPO.h"
#include "llvm/Transforms/Utils/Cloning.h"

#include <iostream>

using namespace llvm;
using namespace std;

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printf("%s <filename>\n", argv[0]);
		return 0;
	}

	const char* source = argv[1];

	//
	// 1) Emit LLVM IR.
	//
	const char* emit_ir_cmd_fmt =
		"kernelgen-gfortran -fplugin=/opt/kernelgen/lib/dragonegg.so -fplugin-arg-dragonegg-emit-ir -S -O1 %s -o -";
	char* emit_ir_cmd = NULL;
	if (build_command(emit_ir_cmd_fmt, &emit_ir_cmd, source))
	{
		fprintf(stderr, "Cannot build command to emit LLVM IR\n");
		return 1;
	}
	printf("%s\n", emit_ir_cmd);
	char* out = NULL; size_t szout = 0;
	char* err = NULL; size_t szerr = 0;
	if (execute(emit_ir_cmd, NULL, 0, &out, &szout, &err, &szerr))
	{
		fprintf(stderr, "Cannot execute command to emit LLVM IR\n");
		return 1;
	}
	free(emit_ir_cmd);

	if (err)
	{
		fprintf(stderr, "Error executing command to emit LLVM IR:\n%s", err);
		return 1;
	}

	printf("%s\n", out);

	//
	// 2) Record existing module functions.
	//
	LLVMContext &context = getGlobalContext();
	SMDiagnostic diag;
	MemoryBuffer* buffer1 = MemoryBuffer::getMemBuffer(out);
	Module* m1 = ParseIR(buffer1, diag, context);
	const Module::FunctionListType& funcList1 = m1->getFunctionList();
  	for (Module::const_iterator it = funcList1.begin();
		it != funcList1.end(); it++)
	{
		const Function &func = *it;
		if (!func.isDeclaration())
			printf("%s\n", func.getName().data());
	}

	//
	// 3) Extract loops into new functions.
	//
	char* in = out; size_t szin = szout;
	MemoryBuffer* buffer2 = MemoryBuffer::getMemBuffer(out);
	Module* m2 = ParseIR(buffer2, diag, context);
	{
		PassManager manager;
		manager.add(createLoopExtractorPass());
		manager.run(*m2);
	}

	//
	// 4) Embed loop functions.
	//
	Function* launch = Function::Create(
		TypeBuilder<int(const char*, int, ...), false>::get(context),
		GlobalValue::ExternalLinkage, "kernelgen_launch_", m2);
	Module::FunctionListType& funcList2 = m2->getFunctionList();
	for (Module::iterator it2 = funcList2.begin();
		it2 != funcList2.end(); it2++)
	{
		Function &func2 = *it2;
		if (func2.isDeclaration()) continue;

		// Search for the current function in original
		// module functions list.
		bool found = false;
		for (Module::const_iterator it1 = funcList1.begin();
			it1 != funcList1.end(); it1++)
		{
			const Function &func1 = *it1;
			if (func1.isDeclaration()) continue;

			if (func1.getName() == func2.getName())
			{
				found = true;
				break;
			}
		}

		// If funtion is not in list of original module,
		// then it is generated by the loop extractor.
		if (found) continue;

		// Each such function must be extracted to the
		// standalone module and packed into resulting
		// object file data section.
		printf("Preparing loop function %s ...\n", func2.getName().data());

		// Replace call to this function in module with call to launcher.
		for (Module::iterator F = m2->begin(); F != m2->end(); F++)
			for (Function::iterator BB = F->begin(); BB != F->end(); BB++)
				for (BasicBlock::iterator I = BB->begin(); I != BB->end(); I++)
				{
					CallInst* call = dyn_cast<CallInst>(cast<Value>(I));
					if (!call) continue;
					Function* callee = call->getCalledFunction();
					if (!callee && !callee->isDeclaration()) continue;
					if (callee->getName() != func2.getName()) continue;

					//ArrayRef<Value*> args;
					//CallInst* newcall = CallInst::Create(launch, args);
					//*call = *newcall;
				}
		
		// Inline all calls in this function.
	}

	raw_ostream* Out = &dbgs();
	(*Out) << (*m2);

	delete m1, m2, buffer1, buffer2;

	return 0;
}

