/*
 * KernelGen - the LLVM-based compiler with GPU kernels generation over C backend.
 *
 * Copyright (c) 2011 Dmitry Mikushin
 *
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising 
 * from the use of this software.
 * Permission is granted to anyone to use this software for any purpose, 
 * including commercial applications, and to alter it and redistribute it freely,
 * subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented;
 * you must not claim that you wrote the original software.
 * If you use this software in a product, an acknowledgment
 * in the product documentation would be appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such,
 * and must not be misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

#include "execute.h"

#include <malloc.h>
#include <stdarg.h>
#include <stdio.h>

// Construct the command line from the specified format
// and parameter list.
static int build_command(const char* fmt, char** cmd, ...)
{
	if (!cmd || !fmt) return 0;
	va_list list;
	va_start(list, cmd);
	int length = vsnprintf(NULL, 0, fmt, list);
	va_end(list);
	if (length < 0) return 1;
	*cmd = (char*)malloc(length + 1);
	va_start(list, cmd);
	vsprintf(*cmd, fmt, list);
	va_end(list);
	return 0;
}

#include "llvm/LLVMContext.h"
#include "llvm/Module.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/IRReader.h"

using namespace llvm;

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printf("%s <filename>\n", argv[0]);
		return 0;
	}

	const char* source = argv[1];

	//
	// 1) Emit LLVM IR.
	//
	const char* emit_ir_cmd_fmt =
		"dragonegg-gfortran -fplugin=/opt/kgen/lib64/dragonegg.so -fplugin-arg-dragonegg-emit-ir -S %s -o -";
	char* emit_ir_cmd = NULL;
	if (build_command(emit_ir_cmd_fmt, &emit_ir_cmd, source))
	{
		fprintf(stderr, "Cannot build command to emit LLVM IR\n");
		return 1;
	}
	printf("%s\n", emit_ir_cmd);
	char* out = NULL; size_t szout = 0;
	char* err = NULL; size_t szerr = 0;
	if (execute(emit_ir_cmd, NULL, 0, &out, &szout, &err, &szerr))
	{
		fprintf(stderr, "Cannot execute command to emit LLVM IR\n");
		return 1;
	}
	free(emit_ir_cmd);

	if (err)
	{
		fprintf(stderr, "Error executing command to emit LLVM IR:\n%s", err);
		return 1;
	}

	//
	// 2) Record existing module functions.
	//
	LLVMContext &context = getGlobalContext();
	SMDiagnostic diag;
	MemoryBuffer* buffer1 = MemoryBuffer::getMemBuffer(out);
	Module* m1 = getLazyIRModule(buffer1, diag, context);
	const Module::FunctionListType& funcList1 = m1->getFunctionList();
  	for (Module::const_iterator it = funcList1.begin();
		it != funcList1.end(); it++)
	{
		const Function &func = *it;
		if (!func.isDeclaration())
			printf("%s\n", func.getName());
	}

	//
	// 3) Extract loops into new functions.
	//
	const char* extract_cmd = "opt -loop-extract -print-module -o /dev/null";
	printf("%s\n", extract_cmd);
	char* in = out; size_t szin = szout;
	if (execute(extract_cmd, in, szin, NULL, 0, &err, &szerr))
	{
		fprintf(stderr, "Cannot execute command to extract loops\n");
		return 1;
	}

	//
	// 4) Embed loop functions.
	//
	MemoryBuffer* buffer2 = MemoryBuffer::getMemBuffer(err);
	Module* m2 = getLazyIRModule(buffer2, diag, context);
	const Module::FunctionListType& funcList2 = m2->getFunctionList();
  	for (Module::const_iterator it2 = funcList2.begin();
		it2 != funcList2.end(); it2++)
	{
		const Function &func2 = *it2;
		if (func2.isDeclaration()) continue;

		// Search for the current function in original
		// module functions list.
		bool found = false;
		for (Module::const_iterator it1 = funcList1.begin();
			it1 != funcList1.end(); it1++)
		{
			const Function &func1 = *it1;
			if (func1.isDeclaration()) continue;

			if (func1.getName() == func2.getName())
			{
				found = true;
				break;
			}
		}

		// If funtion is not in list of original module,
		// then it is generated by the loop extractor.
		if (found) continue;

		// Each such function must be extracted to the
		// standalone module and packed into resulting
		// object file data section.
		printf("%s\n", func2.getName());
	}
	delete m1, m2, buffer1, buffer2;

	//if (out) printf("%s\n", out);

	return 0;
}

