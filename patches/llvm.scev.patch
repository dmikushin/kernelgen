--- a/llvm/include/llvm/Analysis/ScalarEvolution.h	(revision 157485)
+++ b/llvm/include/llvm/Analysis/ScalarEvolution.h	(working copy)
@@ -544,6 +544,15 @@
     static char ID; // Pass identification, replacement for typeid
     ScalarEvolution();
 
+
+    void setAnalysisData( LoopInfo *_LI, TargetData *_TD,TargetLibraryInfo *_TLI, DominatorTree *_DT);
+    void setFunction(Function *f);
+    void setSCEVForValue(Value *V, const SCEV * SCEVForValue);
+    void eraseSCEVForValue(Value *V);
+    void dumpAll();
+    void printAll(raw_ostream &OS);
+    void eraseSCEVsNotInFunction(Function *f);
+
     LLVMContext &getContext() const { return F->getContext(); }
 
     /// isSCEVable - Test if values of the given type are analyzable within
--- a/llvm/lib/Analysis/ScalarEvolution.cpp	(revision 157485)
+++ b/llvm/lib/Analysis/ScalarEvolution.cpp	(working copy)
@@ -4535,23 +4535,65 @@
     if (EL.hasAnyInfo()) return EL;
     break;
   }
+  case ICmpInst::ICMP_SLE: {
+    // Convert to: while (X s< Y+1)
+    const SCEVAddRecExpr *AddRec = dyn_cast<SCEVAddRecExpr>(LHS);
+    const SCEV *Step = AddRec ? AddRec->getStepRecurrence(*this) :
+                       getConstant(RHS->getType(), 1);
+    const SCEV *AddStep = getAddExpr(RHS, Step);
+    ExitLimit EL = HowManyLessThans(LHS, AddStep, L, true);
+    if (EL.hasAnyInfo()) return EL;
+    break;
+  }  
   case ICmpInst::ICMP_SGT: {
     ExitLimit EL = HowManyLessThans(getNotSCEV(LHS),
                                              getNotSCEV(RHS), L, true);
     if (EL.hasAnyInfo()) return EL;
     break;
   }
+  case ICmpInst::ICMP_SGE: {
+    // Convert to: while (X s> Y+1)
+    const SCEVAddRecExpr *AddRec = dyn_cast<SCEVAddRecExpr>(LHS);
+    const SCEV *Step = AddRec ? AddRec->getStepRecurrence(*this) :
+                       getConstant(RHS->getType(), 1);
+    const SCEV *AddStep = getAddExpr(RHS, Step);
+    ExitLimit EL = HowManyLessThans(getNotSCEV(LHS), getNotSCEV(AddStep), L,
+                                    true);
+    if (EL.hasAnyInfo()) return EL;
+    break;
+  }  
   case ICmpInst::ICMP_ULT: {
     ExitLimit EL = HowManyLessThans(LHS, RHS, L, false);
     if (EL.hasAnyInfo()) return EL;
     break;
   }
+  case ICmpInst::ICMP_ULE: {
+    // Convert to: while (X u< Y+1)
+    const SCEVAddRecExpr *AddRec = dyn_cast<SCEVAddRecExpr>(LHS);
+    const SCEV *Step = AddRec ? AddRec->getStepRecurrence(*this) :
+                       getConstant(RHS->getType(), 1);
+    const SCEV *AddStep = getAddExpr(RHS, Step);
+    ExitLimit EL = HowManyLessThans(LHS, AddStep, L, false);
+    if (EL.hasAnyInfo()) return EL;
+    break;
+  }  
   case ICmpInst::ICMP_UGT: {
     ExitLimit EL = HowManyLessThans(getNotSCEV(LHS),
                                              getNotSCEV(RHS), L, false);
     if (EL.hasAnyInfo()) return EL;
     break;
   }
+  case ICmpInst::ICMP_UGE: {
+    // Convert to: while (X u> Y+1)
+    const SCEVAddRecExpr *AddRec = dyn_cast<SCEVAddRecExpr>(LHS);
+    const SCEV *Step = AddRec ? AddRec->getStepRecurrence(*this) :
+                       getConstant(RHS->getType(), 1);
+    const SCEV *AddStep = getAddExpr(RHS, Step);
+    ExitLimit EL = HowManyLessThans(getNotSCEV(LHS), getNotSCEV(AddStep), L,
+                                    false);
+    if (EL.hasAnyInfo()) return EL;
+    break;
+  }  
   default:
 #if 0
     dbgs() << "ComputeBackedgeTakenCount ";
@@ -6285,9 +6327,30 @@
   if (AddRec->isAffine()) {
     unsigned BitWidth = getTypeSizeInBits(AddRec->getType());
     const SCEV *Step = AddRec->getStepRecurrence(*this);
+    
+    // Determine LHS value on first iteration and on last iteration.
+    const SCEV *Start = AddRec->getStart();
 
+    // If we know that the condition is true in order to enter the loop,
+    // then we know that it will run exactly (m-n)/s times. Otherwise, we
+    // only know that it will execute (max(m,n)-n)/s times. In both cases,
+    // the division must round up.
+    const SCEV *End = RHS;
+    if (!isLoopEntryGuardedByCond(L,
+                                  isSigned ? ICmpInst::ICMP_SLT :
+                                             ICmpInst::ICMP_ULT,
+                                  getMinusSCEV(Start, Step), RHS))
+      End = isSigned ? getSMaxExpr(RHS, Start)
+                     : getUMaxExpr(RHS, Start);
+
     if (Step->isZero())
       return getCouldNotCompute();
+    
+    // If Start == End, the only iteration is possible for non zero step.
+    // To avoid additional pass-limit checks just set step to 1.
+    if (Start == End)
+      Step = getConstant(Step->getType(), 1);
+
     if (Step->isOne()) {
       // With unit stride, the iteration never steps past the limit value.
     } else if (isKnownPositive(Step)) {
@@ -6319,26 +6382,11 @@
     // Note that we cannot simply return max(m-n,0)/s because it's not safe to
     // treat m-n as signed nor unsigned due to overflow possibility.
 
-    // First, we get the value of the LHS in the first iteration: n
-    const SCEV *Start = AddRec->getOperand(0);
-
     // Determine the minimum constant start value.
     const SCEV *MinStart = getConstant(isSigned ?
       getSignedRange(Start).getSignedMin() :
       getUnsignedRange(Start).getUnsignedMin());
 
-    // If we know that the condition is true in order to enter the loop,
-    // then we know that it will run exactly (m-n)/s times. Otherwise, we
-    // only know that it will execute (max(m,n)-n)/s times. In both cases,
-    // the division must round up.
-    const SCEV *End = RHS;
-    if (!isLoopEntryGuardedByCond(L,
-                                  isSigned ? ICmpInst::ICMP_SLT :
-                                             ICmpInst::ICMP_ULT,
-                                  getMinusSCEV(Start, Step), RHS))
-      End = isSigned ? getSMaxExpr(RHS, Start)
-                     : getUMaxExpr(RHS, Start);
-
     // Determine the maximum constant end value.
     const SCEV *MaxEnd = getConstant(isSigned ?
       getSignedRange(End).getSignedMax() :
@@ -6944,3 +6992,75 @@
   UnsignedRanges.erase(S);
   SignedRanges.erase(S);
 }
+
+void ScalarEvolution::setSCEVForValue(Value *V, const SCEV * SCEVForValue)
+{
+    ValueExprMap.insert(std::make_pair(SCEVCallbackVH(V, this), SCEVForValue));
+}
+
+void ScalarEvolution::setAnalysisData( LoopInfo *_LI, TargetData *_TD, TargetLibraryInfo *_TLI, DominatorTree *_DT)
+{
+    LI=_LI; TD=_TD; TLI=_TLI; DT=_DT;	
+}
+
+void ScalarEvolution::setFunction(Function *f)
+{ 
+	this->F=f;
+}
+void ScalarEvolution::eraseSCEVForValue(Value *V)
+{
+      for(ValueExprMapType::iterator iter=ValueExprMap.begin(), iterEnd = ValueExprMap.end();
+         iter != iterEnd; iter++) {  
+             SCEVCallbackVH &VH = iter->first;
+             if( ((Value *)VH) == V) {
+                forgetMemoizedResults(iter->second);
+                ValueExprMap.erase(iter);
+                break;  
+             }
+        } 
+}
+void ScalarEvolution::eraseSCEVsNotInFunction(Function *f)
+{
+   std::list<ValueExprMapType::iterator> iterators;
+   for(ValueExprMapType::iterator iter=ValueExprMap.begin(), iterEnd = ValueExprMap.end();
+         iter != iterEnd; iter++) {  
+             SCEVCallbackVH &VH = iter->first;
+             if( Instruction * inst = dyn_cast<Instruction>(((Value *)VH))) { 
+               if(inst -> getParent()->getParent() != f)
+                   iterators.push_back(iter);
+             }
+            if( Argument * arg = dyn_cast<Argument>(((Value *)VH))) { 
+               if(arg -> getParent() != f)
+                   iterators.push_back(iter);
+             }
+        } 
+  for(std::list<ValueExprMapType::iterator>::iterator iter = iterators.begin(), iterEnd = iterators.end();
+        iter != iterEnd; iter++)
+          ValueExprMap.erase(*iter);
+
+}
+void ScalarEvolution::printAll(raw_ostream &OS)
+{
+	for(ValueExprMapType::iterator iter =  ValueExprMap.begin(),
+	   iterEnd = ValueExprMap.end(); iter!= iterEnd; iter++)
+	   {
+		   Value *val = &(*iter->first);
+		   if(Instruction *inst = dyn_cast<Instruction>(val))
+		   {
+		        OS << inst->getParent()->getParent()->getName()<<":";
+                WriteAsOperand(OS,inst,false); 
+                OS <<" --> "<< *(iter->second) << "\n";
+		   }
+			if(Argument *arg = dyn_cast<Argument>(val))
+			{
+		        OS << arg->getParent()->getName() << ":"; 
+				WriteAsOperand(OS,arg,false); 
+				OS << " --> "<< *(iter->second)<< "\n";
+			}
+			
+	   }
+}
+void ScalarEvolution::dumpAll()
+{
+   printAll(dbgs());	
+}
