--- a/lib/Target/CBackend/CBackend.cpp	2011-08-09 13:55:31.443357077 +0400
+++ b/lib/Target/CBackend/CBackend.cpp	2011-08-09 03:30:51.134534946 +0400
@@ -520,7 +521,7 @@
     }
     Out << '}';
     if (STy->isPacked())
-      Out << " __attribute__ ((packed))";
+      Out << "\n#if !defined(__CUDA_DEVICE_FUNC__) && !defined(__OPENCL_DEVICE_FUNC__)\n__attribute__ ((packed))\n#endif // __CUDA_DEVICE_FUNC__\n";
     return Out;
   }
 
@@ -532,6 +533,8 @@
         PTy->getElementType()->isVectorTy())
       ptrName = "(" + ptrName + ")";
 
+    Out << "\n#ifdef __OPENCL_DEVICE_FUNC__\n__global\n#endif // __OPENCL_DEVICE_FUNC__\n";
+    
     if (!PAL.isEmpty())
       // Must be a function ptr cast!
       return printType(Out, PTy->getElementType(), false, ptrName, true, PAL);
@@ -1577,7 +1580,7 @@
   // Output typedefs for 128-bit integers. If these are needed with a
   // 32-bit target or with a C compiler that doesn't support mode(TI),
   // more drastic measures will be needed.
-  Out << "#if __GNUC__ && __LP64__ /* 128-bit integer types */\n"
+  Out << "#if __GNUC__ && __LP64__ && !__CUDA_DEVICE_FUNC__ /* 128-bit integer types */\n"
       << "typedef int __attribute__((mode(TI))) llvmInt128;\n"
       << "typedef unsigned __attribute__((mode(TI))) llvmUInt128;\n"
       << "#endif\n\n";
@@ -1651,6 +1654,45 @@
   }
 }
 
+// Filter out functions tha are predefined for nvcc/nvopen64 compiler,
+// or incompatible definition may clash and cause errors.
+static bool cudaFuncFilter(const std::string &name)
+{
+  std::string cudaFuncs[] =
+  {
+    "abs", "labs", "llabs", "fabs", "fabsf", "min", "umin", "llmin",
+    "ullmin", "fminf", "fmin", "max", "umax", "llmax", "ullmax", "fmax",
+    "fmax", "sin", "cos", "sincos", "sincosf", "tan", "sqrt", "rsqrt",
+    "rsqrtf", "exp2", "exp2f", "exp10", "exp10f", "expm1", "expm1f",
+    "log2", "log2f", "log10", "log", "log1p", "log1pf", "floor", "exp",
+    "cosh", "sinh", "tanh", "acosh", "acoshf", "asinh", "asinhf", "atanh",
+    "atanhf", "ldexp", "ldexpf", "logb", "logbf", "ilogb", "ilogbf",
+    "scalbn", "scalbnf", "scalbln", "scalblnf", "frexp", "frexpf",
+    "round", "roundf", "lround", "lroundf", "llround", "llroundf",
+    "rint", "rintf", "lrint", "lrintf", "llrint", "llrintf", "nearbyint",
+    "nearbyintf", "ceil", "trunc", "truncf", "fdim", "fdimf", "atan2", "atan", 
+    "asin", "acos", "hypot", "hypot", "hypotf", "cbrt", "cbrtf", "rcbrt",
+    "rcbrtf", "sinpi", "sinpif", "cospi", "cospif", "pow", "modf", "fmod",
+    "remainder", "remainderf", "remquo", "remquof", "erf", "erff", "erfinv",
+    "erfinvf", "erfc", "erfcf", "erfcinv", "erfcinvf", "lgamma", "lgammaf",
+    "tgamma", "tgammaf", "copysign", "copysignf", "nextafter", "nextafterf", 
+    "nan", "nanf", "__isinf", "__isinff", "__isnan", "__isnanf", "__isfinited",
+    "__isfinitef", "__signbitd", "__finite", "__finitef", "__signbit", "__signbitf",
+    "fma", "fmaf", "__signbitl", "__isinfl", "__isnanl", "signbit", "isfinite",
+    "isnan", "isinf", "abort", "acosf", "asinf", "atanf", "atan2f", "cosf",
+    "sinf", "tanf", "coshf", "sinhf", "tanhf", "expf", "logf", "log10f", "modff",
+    "powf", "sqrtf", "ceilf", "floorf", "fmodf"
+  };
+  
+  for (unsigned int i = 0; i < sizeof(cudaFuncs) / sizeof(std::string); i++)
+  {
+  	if (name == cudaFuncs[i])
+  		return true;
+  }
+  
+  return false;
+}
+
 // PrintEscapedString - Print each character of the specified string, escaping
 // it if it is not printable or if it is an escape char.
 static void PrintEscapedString(const std::string &Str, raw_ostream &Out) {
@@ -1696,6 +1738,11 @@
       break;
     }
   }
+  
+  // OpenCL pragmas
+  Out << "#ifdef __OPENCL_DEVICE_FUNC__\n";
+  Out << "#pragma OPENCL EXTENSION cl_khr_fp64: enable\n";
+  Out << "#endif\n\n";
 
   // get declaration for alloca
   Out << "/* Provide Declarations */\n";
@@ -1706,7 +1753,7 @@
 
   // Provide a definition for `bool' if not compiling with a C++ compiler.
   Out << "\n"
-      << "#ifndef __cplusplus\ntypedef unsigned char bool;\n#endif\n"
+      << "#if !defined(__cplusplus) && !defined(__OPENCL_DEVICE_FUNC__)\ntypedef unsigned char bool;\n#endif\n"
 
       << "\n\n/* Support for floating point constants */\n"
       << "typedef unsigned long long ConstantDoubleTy;\n"
@@ -1751,12 +1798,19 @@
   // Global variable declarations...
   if (!M.global_empty()) {
     Out << "\n/* External Global Variable Declarations */\n";
+    Out << "#ifdef __OPENCL_DEVICE_FUNC__\n#pragma pack(push, 1)\nstruct $kernel_name$_globals_t {\n";
+    Out << "#endif // __OPENCL_DEVICE_FUNC__\n";
     for (Module::global_iterator I = M.global_begin(), E = M.global_end();
          I != E; ++I) {
 
       if (I->hasExternalLinkage() || I->hasExternalWeakLinkage() ||
           I->hasCommonLinkage())
-        Out << "extern ";
+      {
+        Out << "#ifdef __CUDA_DEVICE_FUNC__\n#define " << GetValueName(I) << " " <<
+          GetValueName(I) << "_$kernel_name$\n__device__\n#else\n" <<
+          "#ifndef __OPENCL_DEVICE_FUNC__\nextern\n#endif // __OPENCL_DEVICE_FUNC__\n" <<
+          "#endif // __CUDA_DEVICE_FUNC__\n";
+      }
       else if (I->hasDLLImportLinkage())
         Out << "__declspec(dllimport) ";
       else
@@ -1771,14 +1825,24 @@
       if (I->hasExternalWeakLinkage())
          Out << " __EXTERNAL_WEAK__";
       Out << ";\n";
+      if (I->hasExternalLinkage() || I->hasExternalWeakLinkage() ||
+          I->hasCommonLinkage())
+      {
+        Out << "#ifdef __OPENCL_DEVICE_FUNC__\n#define " << GetValueName(I) << " " <<
+          "($kernel_name$_globals->" << GetValueName(I) << ")\n#endif // __OPENCL_DEVICE_FUNC__\n";
+      }
     }
+    Out << "#ifdef __OPENCL_DEVICE_FUNC__\n};\n#pragma pack(pop)\n";
+    Out << "#endif // __OPENCL_DEVICE_FUNC__\n";
   }
 
   // Function declarations
   Out << "\n/* Function Declarations */\n";
+  Out << "#if !defined(__CUDA_DEVICE_FUNC__) && !defined(__OPENCL_DEVICE_FUNC__)\n";
   Out << "double fmod(double, double);\n";   // Support for FP rem
   Out << "float fmodf(float, float);\n";
   Out << "long double fmodl(long double, long double);\n";
+  Out << "#endif // __CUDA_DEVICE_FUNC__\n";
 
   // Store the intrinsics which will be declared/defined below.
   SmallVector<const Function*, 8> intrinsicsToDefine;
@@ -1802,6 +1866,12 @@
         I->getName() == "longjmp" || I->getName() == "_setjmp")
       continue;
 
+    int cudaFiltered = cudaFuncFilter(I->getName());
+    if (cudaFiltered)
+      Out << "#if !defined(__CUDA_DEVICE_FUNC__) && !defined(__OPENCL_DEVICE_FUNC__)\n";
+    else
+      Out << "#ifdef __CUDA_DEVICE_FUNC__\n__device__\n#endif\n";
+
     if (I->hasExternalWeakLinkage())
       Out << "extern ";
     printFunctionSignature(I, true);
@@ -1820,6 +1890,9 @@
       Out << " LLVM_ASM(\"" << I->getName().substr(1) << "\")";
 
     Out << ";\n";
+
+    if (cudaFiltered)
+      Out << "#endif // __CUDA_DEVICE_FUNC__ && __OPENCL_DEVICE_FUNC__\n";
   }
 
   // Output the global variable declarations
@@ -1835,7 +1908,9 @@
         if (I->hasLocalLinkage())
           Out << "static ";
         else
-          Out << "extern ";
+        {
+          Out << "#ifndef __CUDA_DEVICE_FUNC__\nextern";
+        }
 
         // Thread Local Storage
         if (I->isThreadLocal())
@@ -1855,6 +1930,9 @@
         if (I->hasHiddenVisibility())
           Out << " __HIDDEN__";
         Out << ";\n";
+
+        if (!I->hasLocalLinkage())
+          Out << "#endif // __CUDA_DEVICE_FUNC__\n";
       }
   }
 
@@ -1868,6 +1946,8 @@
         if (getGlobalVariableClass(I))
           continue;
 
+        Out << "#ifndef __CUDA_DEVICE_FUNC__\nextern";
+
         if (I->hasLocalLinkage())
           Out << "static ";
         else if (I->hasDLLImportLinkage())
@@ -1918,6 +1998,7 @@
           }
         }
         Out << ";\n";
+        Out << "#endif // __CUDA_DEVICE_FUNC__\n";
       }
   }
 
@@ -1926,34 +2007,20 @@
 
   // Emit some helper functions for dealing with FCMP instruction's
   // predicates
-  Out << "static inline int llvm_fcmp_ord(double X, double Y) { ";
-  Out << "return X == X && Y == Y; }\n";
-  Out << "static inline int llvm_fcmp_uno(double X, double Y) { ";
-  Out << "return X != X || Y != Y; }\n";
-  Out << "static inline int llvm_fcmp_ueq(double X, double Y) { ";
-  Out << "return X == Y || llvm_fcmp_uno(X, Y); }\n";
-  Out << "static inline int llvm_fcmp_une(double X, double Y) { ";
-  Out << "return X != Y; }\n";
-  Out << "static inline int llvm_fcmp_ult(double X, double Y) { ";
-  Out << "return X <  Y || llvm_fcmp_uno(X, Y); }\n";
-  Out << "static inline int llvm_fcmp_ugt(double X, double Y) { ";
-  Out << "return X >  Y || llvm_fcmp_uno(X, Y); }\n";
-  Out << "static inline int llvm_fcmp_ule(double X, double Y) { ";
-  Out << "return X <= Y || llvm_fcmp_uno(X, Y); }\n";
-  Out << "static inline int llvm_fcmp_uge(double X, double Y) { ";
-  Out << "return X >= Y || llvm_fcmp_uno(X, Y); }\n";
-  Out << "static inline int llvm_fcmp_oeq(double X, double Y) { ";
-  Out << "return X == Y ; }\n";
-  Out << "static inline int llvm_fcmp_one(double X, double Y) { ";
-  Out << "return X != Y && llvm_fcmp_ord(X, Y); }\n";
-  Out << "static inline int llvm_fcmp_olt(double X, double Y) { ";
-  Out << "return X <  Y ; }\n";
-  Out << "static inline int llvm_fcmp_ogt(double X, double Y) { ";
-  Out << "return X >  Y ; }\n";
-  Out << "static inline int llvm_fcmp_ole(double X, double Y) { ";
-  Out << "return X <= Y ; }\n";
-  Out << "static inline int llvm_fcmp_oge(double X, double Y) { ";
-  Out << "return X >= Y ; }\n";
+  Out << "#define llvm_fcmp_ord(X, Y) ((X) == (X) && (Y) == (Y))\n";
+  Out << "#define llvm_fcmp_uno(X, Y) ((X) != (X) || (Y) != (Y))\n";
+  Out << "#define llvm_fcmp_ueq(X, Y) ((X) == (Y) || llvm_fcmp_uno(X, Y))\n";
+  Out << "#define llvm_fcmp_une(X, Y) ((X) != (Y))\n";
+  Out << "#define llvm_fcmp_ult(X, Y) ((X) <  (Y) || llvm_fcmp_uno(X, Y))\n";
+  Out << "#define llvm_fcmp_ugt(X, Y) ((X) >  (Y) || llvm_fcmp_uno(X, Y))\n";
+  Out << "#define llvm_fcmp_ule(X, Y) ((X) <= (Y) || llvm_fcmp_uno(X, Y))\n";
+  Out << "#define llvm_fcmp_uge(X, Y) ((X) >= (Y) || llvm_fcmp_uno(X, Y))\n";
+  Out << "#define llvm_fcmp_oeq(X, Y) ((X) == (Y))\n";
+  Out << "#define llvm_fcmp_one(X, Y) ((X) != (Y) && llvm_fcmp_ord(X, Y))\n";
+  Out << "#define llvm_fcmp_olt(X, Y) ((X) <  (Y))\n";
+  Out << "#define llvm_fcmp_ogt(X, Y) ((X) >  (Y))\n";
+  Out << "#define llvm_fcmp_ole(X, Y) ((X) <= (Y))\n";
+  Out << "#define llvm_fcmp_oge(X, Y) ((X) >= (Y))\n";
 
   // Emit definitions of the intrinsics.
   for (SmallVector<const Function*, 8>::const_iterator
@@ -2002,6 +2069,7 @@
   if (FPC->getType() == Type::getDoubleTy(FPC->getContext())) {
     double Val = FPC->getValueAPF().convertToDouble();
     uint64_t i = FPC->getValueAPF().bitcastToAPInt().getZExtValue();
+    Out << "#ifdef __CUDA_DEVICE_FUNC__\n__device__\n#endif // __CUDA_DEVICE_FUNC__\n";
     Out << "static const ConstantDoubleTy FPConstant" << FPCounter++
     << " = 0x" << utohexstr(i)
     << "ULL;    /* " << Val << " */\n";
@@ -2009,6 +2077,7 @@
     float Val = FPC->getValueAPF().convertToFloat();
     uint32_t i = (uint32_t)FPC->getValueAPF().bitcastToAPInt().
     getZExtValue();
+    Out << "#ifdef __CUDA_DEVICE_FUNC__\n__device__\n#endif // __CUDA_DEVICE_FUNC__\n";
     Out << "static const ConstantFloatTy FPConstant" << FPCounter++
     << " = 0x" << utohexstr(i)
     << "U;    /* " << Val << " */\n";
@@ -2016,6 +2085,7 @@
     // api needed to prevent premature destruction
     APInt api = FPC->getValueAPF().bitcastToAPInt();
     const uint64_t *p = api.getRawData();
+    Out << "#ifdef __CUDA_DEVICE_FUNC__\n__device__\n#endif // __CUDA_DEVICE_FUNC__\n";
     Out << "static const ConstantFP80Ty FPConstant" << FPCounter++
     << " = { 0x" << utohexstr(p[0])
     << "ULL, 0x" << utohexstr((uint16_t)p[1]) << ",{0,0,0}"
@@ -2024,6 +2094,7 @@
              FPC->getType() == Type::getFP128Ty(FPC->getContext())) {
     APInt api = FPC->getValueAPF().bitcastToAPInt();
     const uint64_t *p = api.getRawData();
+    Out << "#ifdef __CUDA_DEVICE_FUNC__\n__device__\n#endif // __CUDA_DEVICE_FUNC__\n";
     Out << "static const ConstantFP128Ty FPConstant" << FPCounter++
     << " = { 0x"
     << utohexstr(p[0]) << ", 0x" << utohexstr(p[1])
@@ -2247,9 +2318,9 @@
   // Finish printing arguments... if this is a vararg function, print the ...,
   // unless there are no known types, in which case, we just emit ().
   //
-  if (FT->isVarArg() && PrintedArg) {
+  /*if (FT->isVarArg() && PrintedArg) {
     FunctionInnards << ",...";  // Output varargs portion of signature!
-  } else if (!FT->isVarArg() && !PrintedArg) {
+  } else*/ if (!FT->isVarArg() && !PrintedArg) {
     FunctionInnards << "void"; // ret() -> ret(void) in C.
   }
   FunctionInnards << ')';
@@ -3477,9 +3548,9 @@
   bool IsUnaligned = Alignment &&
     Alignment < TD->getABITypeAlignment(OperandType);
 
-  if (!IsUnaligned)
+  //if (!IsUnaligned)
     Out << '*';
-  if (IsVolatile || IsUnaligned) {
+  /*if (IsVolatile || IsUnaligned) {
     Out << "((";
     if (IsUnaligned)
       Out << "struct __attribute__ ((packed, aligned(" << Alignment << "))) {";
@@ -3490,15 +3561,15 @@
       Out << "*";
     }
     Out << ")";
-  }
+  }*/
 
   writeOperand(Operand);
 
-  if (IsVolatile || IsUnaligned) {
+  /*if (IsVolatile || IsUnaligned) {
     Out << ')';
     if (IsUnaligned)
       Out << "->data";
-  }
+  }*/
 }
 
 void CWriter::visitLoadInst(LoadInst &I) {
