--- /dev/null	2012-03-08 13:55:00.716834004 +0300
+++ b/gcc-4.6.3/gcc/main.cpp	2012-03-08 15:05:24.714095594 +0300
@@ -0,0 +1,247 @@
+/* main.c: defines main() for cc1, cc1plus, etc.
+   Copyright (C) 2007, 2010  Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+extern "C"
+{
+  #include "config.h"
+  #include "system.h"
+  #include "coretypes.h"
+  #include "tm.h"
+  #include "diagnostic-core.h"
+  #include "params.h"
+  #include "toplev.h"
+  #include <stdlib.h>
+  #include <fcntl.h>
+  #include <gelf.h>	
+  #include <libelf.h>
+}
+
+#include <string>
+#include <vector>
+
+using namespace std;
+
+/* We define main() to call toplev_main(), which is defined in toplev.c.
+   We do this in a separate file in order to allow the language front-end
+   to define a different main(), if it so desires.  */
+int main (int argc, char **argv);
+
+/* We define an intermediate buffer to store the dragonegg.so plugin result.
+   It will be then used as libkernelgen-ct.so plugin input.  */
+string dragonegg_result = "";
+
+int
+main (int argc, char **argv)
+{
+  // Check if environment defines KERNELGEN_PLUGINS_PATH.
+  // If it does not, then use the default setting.
+  string kernelgen_plugins_path = "/opt/kernelgen/lib/";
+  const char* plugins_path = getenv("KERNELGEN_PLUGINS_PATH");
+  if (plugins_path) kernelgen_plugins_path = plugins_path;
+
+  // It seems GCC does not care about cleaning up its
+  // state completely after processing. Well, it's reasonable,
+  // since the tool is not really designed to support multiple
+  // compilation passes in a single launch.
+  // In out approach we perform two compilation passes, thus
+  // GCC state must be reset before the second pass.
+  // To archive that, we will backup .data and .bss symbols
+  // initla state and rewrite them after finishing the first pass.
+  const char* filename = "/proc/self/exe";
+  int fd = open(filename, O_RDONLY);
+  if (fd < 0)
+  {
+    fprintf(stderr, "Cannot open %s\n", filename);
+    return 1;
+  }
+  if (elf_version(EV_CURRENT) == EV_NONE)
+  {
+    fprintf(stderr, "ELF library initialization failed: %s\n",
+      elf_errmsg(-1));
+    return 1;
+  }
+  Elf* e = elf_begin(fd, ELF_C_READ, NULL);
+  if (!e)
+  {
+    fprintf(stderr, "elf_begin() failed: %s\n", elf_errmsg(-1));
+    return 1;
+  }
+  size_t shstrndx;
+  if (elf_getshdrstrndx(e, &shstrndx))
+  {
+    fprintf(stderr, "elf_getshdrstrndx() failed: %s\n",
+      elf_errmsg(-1));
+    return 1;
+  }
+  Elf_Data* symbols = NULL;
+  int nsymbols = 0, idata = -1, ibss = -1;
+  Elf_Scn* scn = elf_nextscn(e, NULL);
+  for (int i = 1; scn != NULL; scn = elf_nextscn(e, scn), i++)
+  {
+    GElf_Shdr shdr;
+    if (!gelf_getshdr(scn, &shdr))
+    {
+      fprintf(stderr, "gelf_getshdr() failed for %s\n",
+        elf_errmsg(-1));
+      return 1;
+    }
+
+    if (shdr.sh_type == SHT_SYMTAB)
+    {
+      symbols = elf_getdata(scn, NULL);
+      if (!symbols)
+      {
+        fprintf(stderr, "elf_getdata() failed for %s\n",
+          elf_errmsg(-1));
+        return 1;
+      }
+      if (shdr.sh_entsize)
+        nsymbols = shdr.sh_size / shdr.sh_entsize;
+    }
+
+    char* name = NULL;
+    if ((name = elf_strptr(e, shstrndx, shdr.sh_name)) == NULL)
+    {
+      fprintf(stderr, "Cannot read the section %d name\n", i);
+    }
+
+    if (!strcmp(name, ".data")) idata = i;
+    if (!strcmp(name, ".bss")) ibss = i;
+  }
+  if (!symbols)
+  {
+    fprintf(stderr, "Cannot find symbols table\n");
+    return 1;
+  }
+
+  // For each symbol:
+  // If symbol is object, account its size.
+  // Also track the total number of objects.
+  size_t obj_total_size = 0, nobj = 0;
+  for (int isymbol = 0; isymbol < nsymbols; isymbol++)
+  {
+    GElf_Sym symbol;
+    gelf_getsym(symbols, isymbol, &symbol);
+    if ((GELF_ST_TYPE(symbol.st_info) == STT_OBJECT) &&
+      ((symbol.st_shndx == idata) || (symbol.st_shndx == ibss)))
+    {
+      obj_total_size += symbol.st_size;
+      nobj++;
+    }
+  }
+
+  // Allocate a vector to store objects initial values
+  vector<char> obj_data_vector;
+  obj_data_vector.resize(obj_total_size);
+  char* obj_data = (char*)&obj_data_vector[0];
+
+  // Allocate a vector to store objects sizes.
+  vector<size_t> obj_size_vector;
+  obj_size_vector.resize(nobj);
+  size_t* obj_size = (size_t*)&obj_size_vector[0];
+
+  // For each symbol:
+  // If symbol is object, record its size and initial content.
+  char* obj_data_ptr = obj_data;
+  for (int isymbol = 0, iobj = 0; isymbol < nsymbols; isymbol++)
+  {
+    GElf_Sym symbol;
+    gelf_getsym(symbols, isymbol, &symbol);
+    if ((GELF_ST_TYPE(symbol.st_info) == STT_OBJECT) &&
+      ((symbol.st_shndx == idata) || (symbol.st_shndx == ibss)))
+    {
+      memcpy(obj_data_ptr, (const void*)symbol.st_value, symbol.st_size);
+      obj_data_ptr += symbol.st_size;
+      obj_size[iobj++] = symbol.st_size;
+    }
+  }
+
+  // Run compiler with dragonegg plugin enabled.
+  // DragonEgg trashes the regular gcc output, so we
+  // will need to invoke gcc once again to get the regular
+  // assembly output.
+  // TODO: and kernelgen-rt plugin??
+  int rcompiler = 0;
+  {
+    // Create new argc & argv.
+    int compiler_argc = argc + 5; // + 5 more arguments
+    vector<const char*> compiler_argv_vector;
+    compiler_argv_vector.resize(compiler_argc);
+    char** compiler_argv = (char**)&compiler_argv_vector[0];
+    compiler_argv[0] = argv[0];
+    int i = 0; for ( ; i < argc; i++)
+      compiler_argv[i] = argv[i];
+    string plugin_path = "-fplugin=" + kernelgen_plugins_path + "dragonegg.so";
+    compiler_argv[i++] = (char*)plugin_path.c_str();
+    compiler_argv[i++] = "-fplugin-arg-dragonegg-emit-ir";
+    compiler_argv[i++] = "-fplugin-arg-dragonegg-llvm-ir-optimize=0";
+    compiler_argv[i++] = "-fplugin-arg-dragonegg-internal-output";
+    compiler_argv[i++] = "-D_KERNELGEN";
+
+    rcompiler = toplev_main(compiler_argc, compiler_argv);
+  }
+
+  // Check the DragonEgg result.
+  // If no result or error status, then exit now.
+  if (!dragonegg_result.size() || rcompiler) return rcompiler;
+
+  // Backup the DragonEgg result.
+  string dragonegg_result_backup = dragonegg_result;
+
+  // For each symbol:
+  // If symbol is object, restore its initial value.
+  obj_data_ptr = obj_data;
+  for (int isymbol = 0; isymbol < nsymbols; isymbol++)
+  {
+    GElf_Sym symbol;
+    gelf_getsym(symbols, isymbol, &symbol);
+    if ((GELF_ST_TYPE(symbol.st_info) == STT_OBJECT) &&
+      ((symbol.st_shndx == idata) || (symbol.st_shndx == ibss)))
+    {
+      memcpy((void*)symbol.st_value, obj_data_ptr, symbol.st_size);
+      obj_data_ptr += symbol.st_size;
+    }
+  }
+  elf_end(e);
+
+  // Restore the DragonEgg result.
+  dragonegg_result = dragonegg_result_backup;
+
+  // Run compiler with kernelgen-ct.
+  // This time compiler should generate a regular assembly
+  // file, where plugin also inserts a symbol containing
+  // DragonEgg output.
+  {
+    // Create new argc & argv.
+    int compiler_argc = argc + 2; // + 2 more arguments
+    vector<const char*> compiler_argv_vector;
+    compiler_argv_vector.resize(compiler_argc);
+    char** compiler_argv = (char**)&compiler_argv_vector[0];
+    compiler_argv[0] = argv[0];
+    int i = 0; for ( ; i < argc; i++)
+      compiler_argv[i] = argv[i];
+    string plugin_path = "-fplugin=" + kernelgen_plugins_path + "libkernelgen-ct.so";
+    compiler_argv[i++] = (char*)plugin_path.c_str();
+    compiler_argv[i++] = "-D_KERNELGEN";
+
+    rcompiler = toplev_main(compiler_argc, compiler_argv);
+  }
+
+  return rcompiler;
+}
--- a/gcc-4.6.3/gcc/main.c	2011-01-03 23:52:00.000000000 +0300
+++ /dev/null	2012-03-08 13:55:00.716834004 +0300
@@ -1,37 +0,0 @@
-/* main.c: defines main() for cc1, cc1plus, etc.
-   Copyright (C) 2007, 2010  Free Software Foundation, Inc.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify it under
-the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 3, or (at your option) any later
-version.
-
-GCC is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
-
-#include "config.h"
-#include "system.h"
-#include "coretypes.h"
-#include "tm.h"
-#include "diagnostic-core.h"
-#include "toplev.h"
-
-int main (int argc, char **argv);
-
-/* We define main() to call toplev_main(), which is defined in toplev.c.
-   We do this in a separate file in order to allow the language front-end
-   to define a different main(), if it so desires.  */
-
-int
-main (int argc, char **argv)
-{
-  return toplev_main (argc, argv);
-}
--- a/gcc-4.6.3/gcc/collect2.c	2011-01-06 21:50:00.000000000 +0300
+++ b/gcc-4.6.3/gcc/collect2.c	2012-03-12 20:54:07.031433472 +0300
@@ -206,7 +206,8 @@
 static char **lto_o_files;		/* Output files for LTO.  */
 const char *ldout;			/* File for ld stdout.  */
 const char *lderrout;			/* File for ld stderr.  */
-static const char *output_file;		/* Output file for ld.  */
+static const char *output_file;		/* Output file for ld. */
+static char tmp_output_file[L_tmpnam + 8];
 static const char *nm_file_name;	/* pathname of nm */
 #ifdef LDD_SUFFIX
 static const char *ldd_file_name;	/* pathname of ldd (or equivalent) */
@@ -412,8 +413,8 @@
       maybe_unlink (lderrout);
     }
 
-  if (status != 0 && output_file != 0 && output_file[0])
-    maybe_unlink (output_file);
+  if (status != 0 && tmp_output_file != 0 && tmp_output_file[0])
+    maybe_unlink (tmp_output_file);
 
   if (response_file)
     maybe_unlink (response_file);
@@ -1245,6 +1246,8 @@
 #else
   output_file = DEFAULT_A_OUT_NAME;
 #endif
+  sprintf(tmp_output_file, "%s/XXXXXX", P_tmpdir);
+  mkstemp(tmp_output_file);
 
   obstack_begin (&temporary_obstack, 0);
   temporary_firstobj = (char *) obstack_alloc (&temporary_obstack, 0);
@@ -1529,8 +1532,10 @@
 #endif
 
 	    case 'o':
-	      if (arg[2] == '\0')
-		output_file = *ld1++ = *ld2++ = *++argv;
+	      if (arg[2] == '\0') {
+		output_file = *++argv;
+                *ld1++ = *ld2++ = tmp_output_file;
+              }
 	      else
 		output_file = &arg[2];
 	      break;
@@ -1786,10 +1791,10 @@
      destructor tables to a .s file and reload.  */
 
   if (ld1_filter != SCAN_NOTHING)
-    scan_prog_file (output_file, PASS_FIRST, ld1_filter);
+    scan_prog_file (tmp_output_file, PASS_FIRST, ld1_filter);
 
 #ifdef SCAN_LIBRARIES
-  scan_libraries (output_file);
+  scan_libraries (tmp_output_file);
 #endif
 
   if (debug)
@@ -1837,7 +1842,7 @@
 						  real_strip_argv);
 
 	  strip_argv[0] = strip_file_name;
-	  strip_argv[1] = output_file;
+	  strip_argv[1] = tmp_output_file;
 	  strip_argv[2] = (char *) 0;
 	  fork_execute ("strip", real_strip_argv);
 	}
@@ -1856,7 +1861,7 @@
   sort_ids (&constructors);
   sort_ids (&destructors);
 
-  maybe_unlink(output_file);
+  maybe_unlink(tmp_output_file);
   outf = fopen (c_file, "w");
   if (outf == (FILE *) 0)
     fatal_perror ("fopen %s", c_file);
@@ -1906,8 +1911,8 @@
 
   if (debug)
     {
-      fprintf (stderr, "\n========== output_file = %s, c_file = %s\n",
-	       output_file, c_file);
+      fprintf (stderr, "\n========== tmp_output_file = %s, c_file = %s\n",
+	       tmp_output_file, c_file);
       write_c_file (stderr, "stderr");
       fprintf (stderr, "========== end of c_file\n\n");
 #ifdef COLLECT_EXPORT_LIST
@@ -1939,7 +1944,7 @@
 
   /* Let scan_prog_file do any final mods (OSF/rose needs this for
      constructors/destructors in shared libraries.  */
-  scan_prog_file (output_file, PASS_SECOND, SCAN_ALL);
+  scan_prog_file (tmp_output_file, PASS_SECOND, SCAN_ALL);
 #endif
 
   maybe_unlink (c_file);
@@ -2313,10 +2318,10 @@
   char *prefix, *r;
   int frames = (frame_tables.number > 0);
 
-  /* Figure out name of output_file, stripping off .so version.  */
-  p = strrchr (output_file, '/');
+  /* Figure out name of tmp_output_file, stripping off .so version.  */
+  p = strrchr (tmp_output_file, '/');
   if (p == 0)
-    p = output_file;
+    p = tmp_output_file;
   else
     p++;
   q = p;
@@ -2348,7 +2353,7 @@
       *r = '_';
   if (debug)
     notice ("\nwrite_c_file - output name is %s, prefix is %s\n",
-	    output_file, prefix);
+	    tmp_output_file, prefix);
 
   initname = concat ("_GLOBAL__FI_", prefix, NULL);
   fininame = concat ("_GLOBAL__FD_", prefix, NULL);
@@ -3255,7 +3260,7 @@
 }
 
 static void
-do_dsymutil (const char *output_file) {
+do_dsymutil (const char *tmp_output_file) {
   const char *dsymutil = DSYMUTIL + 1;
   struct pex_obj *pex;
   char **real_argv = XCNEWVEC (char *, 3);
@@ -3263,7 +3268,7 @@
 				    real_argv);
 
   argv[0] = dsymutil;
-  argv[1] = output_file;
+  argv[1] = tmp_output_file;
   argv[2] = (char *) 0;
 
   pex = collect_execute (dsymutil, real_argv, NULL, NULL, PEX_LAST | PEX_SEARCH);
@@ -3275,10 +3280,25 @@
   if (!(temp_file && flag_idsym) && !flag_dsym)
     return;
       
-  do_dsymutil (output_file);
+  do_dsymutil (tmp_output_file);
 }
 #else
+typedef void (*kernelgen_link_t)(const char* input, const char* output);
 static void
 process_args (int *argcp ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED) { }
-static void post_ld_pass (bool temp_file ATTRIBUTE_UNUSED) { }
+static void post_ld_pass (bool temp_file ATTRIBUTE_UNUSED) {
+  // Check if environment defines KERNELGEN_PLUGINS_PATH.
+  // If it does not, then use the default setting.
+  char* kernelgen_plugins_path = "/opt/kernelgen/lib/";
+  char* plugins_path = getenv("KERNELGEN_PLUGINS_PATH");
+  if (plugins_path) kernelgen_plugins_path = plugins_path;
+
+  // Load the link-time plugin and execute its link command.
+  const char* filename = "libkernelgen-lt.so";
+  char filepath[strlen(kernelgen_plugins_path) + strlen(filename)];
+  sprintf(filepath, "%s%s", kernelgen_plugins_path, filename);
+  void* handle = dlopen(filepath, RTLD_NOW);
+  kernelgen_link_t kernelgen_link = (kernelgen_link_t)dlsym(handle, "kernelgen_link");
+  kernelgen_link(tmp_output_file, output_file);
+}
 #endif
--- a/gcc-4.6.3/build/gcc/Makefile	2012-03-12 23:24:20.298118079 +0300
+++ b/gcc-4.6.3/build/gcc/Makefile	2012-03-12 23:26:13.545700651 +0300
@@ -50,7 +50,7 @@
 # This must come before the language makefile fragments to allow them to
 # add suffixes and rules of their own.
 .SUFFIXES:
-.SUFFIXES: .c .o .po .pox .gmo
+.SUFFIXES: .c .cpp .o .po .pox .gmo
 
 # -------------------------------
 # Standard autoconf-set variables
@@ -196,7 +196,7 @@
 
 AWK = gawk
 CC =  /home/marcusmae/rpmbuild/BUILD/gcc-4.6.3/build/./prev-gcc/xgcc -B/home/marcusmae/rpmbuild/BUILD/gcc-4.6.3/build/./prev-gcc/ -B/home/marcusmae/rpmbuild/BUILDROOT/kernelgen-0.2-accurate.x86_64/opt/kernelgen/x86_64-unknown-linux-gnu/bin/ -B/home/marcusmae/rpmbuild/BUILDROOT/kernelgen-0.2-accurate.x86_64/opt/kernelgen/x86_64-unknown-linux-gnu/bin/ -B/home/marcusmae/rpmbuild/BUILDROOT/kernelgen-0.2-accurate.x86_64/opt/kernelgen/x86_64-unknown-linux-gnu/lib/ -isystem /home/marcusmae/rpmbuild/BUILDROOT/kernelgen-0.2-accurate.x86_64/opt/kernelgen/x86_64-unknown-linux-gnu/include -isystem /home/marcusmae/rpmbuild/BUILDROOT/kernelgen-0.2-accurate.x86_64/opt/kernelgen/x86_64-unknown-linux-gnu/sys-include   
-CXX = g++
+CXX = g++ -DPLUGIN_PREFIX=\"/opt/kernelgen/lib/\"
 BISON = bison
 BISONFLAGS =
 FLEX = flex
@@ -215,7 +215,7 @@
 ifneq ($(ENABLE_BUILD_WITH_CXX),yes)
 COMPILER = $(CC)
 COMPILER_FLAGS = $(CFLAGS)
-LINKER = $(CC)
+LINKER = $(CXX)
 LINKER_FLAGS = $(CFLAGS)
 else
 COMPILER = $(CXX)
@@ -1037,7 +1037,7 @@
 LIBS =  $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER) \
 	$(HOST_LIBS)
 BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \
-	$(ZLIB)
+	$(ZLIB) -lelf
 # Any system libraries needed just for GNAT.
 SYSLIBS = 
 
@@ -1070,6 +1070,9 @@
 	   $(CPPINC) $(GMPINC) $(DECNUMINC) \
 	   $(PPLINC) $(CLOOGINC)
 
+.cpp.o:
+	$(CXX) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)
+
 .c.o:
 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $< $(OUTPUT_OPTION)
 
@@ -2083,7 +2086,7 @@
 sparseset.o: sparseset.c $(SYSTEM_H) sparseset.h $(CONFIG_H)
 
 COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o intl.o version.o
-COLLECT2_LIBS = 
+COLLECT2_LIBS = -ldl
 collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)
 # Don't try modifying collect2 (aka ld) in place--it might be linking this.
 	+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o T$@ \
@@ -2858,7 +2861,7 @@
 plugin.o : plugin.c $(PLUGIN_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    $(DIAGNOSTIC_CORE_H) $(TREE_H) $(TREE_PASS_H) intl.h $(PLUGIN_VERSION_H) $(GGC_H)
 
-main.o : main.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H)
+main.o : main.cpp $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H)
 
 host-default.o : host-default.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
    hosthooks.h $(HOSTHOOKS_DEF_H)
