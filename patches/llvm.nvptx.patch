--- a/llvm/lib/MC/MCAsmStreamer.cpp	2012-10-19 01:21:57.160626454 +0200
+++ b/llvm/lib/MC/MCAsmStreamer.cpp	2012-10-19 01:23:11.088629695 +0200
@@ -451,8 +451,8 @@
   case MCSA_Protected:      OS << "\t.protected\t";       break;
   case MCSA_Reference:      OS << "\t.reference\t";       break;
   case MCSA_Weak:           OS << "\t.weak\t";            break;
-  case MCSA_WeakDefinition:
-    OS << "\t.weak_definition\t";
+  case MCSA_WeakDefinition: // .weak_definition
+    OS << MAI.getWeakDefDirective();
     FlagMap[Symbol] |= EHWeakDefinition;
     break;
       // .weak_reference
--- a/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp	2012-10-19 01:30:56.160650096 +0200
+++ b/llvm/lib/Target/NVPTX/MCTargetDesc/NVPTXMCAsmInfo.cpp	2012-10-19 01:18:55.828618499 +0200
@@ -60,4 +60,6 @@
 
   // @TODO: Can we just disable this?
   GlobalDirective = "\t// .globl\t";
+  AlignDirective = "\t// .align\t";
+  WeakDefDirective = "\t// .weak\t";
 }
--- a/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp	(revision 181135)
+++ b/llvm/lib/Target/NVPTX/NVPTXFrameLowering.cpp	(working copy)
@@ -39,15 +39,26 @@
     if (tm.getSubtargetImpl()->hasGenericLdSt()) {
       // mov %SPL, %depot;
       // cvta.local %SP, %SPL;
+      // or
+      // cvta.global %SP, %SPL;
+      // TODO: allow loop kernels to use local memory
       if (is64bit) {
         MachineInstr *MI = BuildMI(
+#if 0
             MBB, MBBI, dl, tm.getInstrInfo()->get(NVPTX::cvta_local_yes_64),
+#else
+            MBB, MBBI, dl, tm.getInstrInfo()->get(NVPTX::cvta_global_yes_64),
+#endif
             NVPTX::VRFrame).addReg(NVPTX::VRFrameLocal);
         BuildMI(MBB, MI, dl, tm.getInstrInfo()->get(NVPTX::IMOV64rr),
                 NVPTX::VRFrameLocal).addReg(NVPTX::VRDepot);
       } else {
         MachineInstr *MI = BuildMI(
+#if 0
             MBB, MBBI, dl, tm.getInstrInfo()->get(NVPTX::cvta_local_yes),
+#else
+            MBB, MBBI, dl, tm.getInstrInfo()->get(NVPTX::cvta_global_yes),
+#endif
             NVPTX::VRFrame).addReg(NVPTX::VRFrameLocal);
         BuildMI(MBB, MI, dl, tm.getInstrInfo()->get(NVPTX::IMOV32rr),
                 NVPTX::VRFrameLocal).addReg(NVPTX::VRDepot);
--- a/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp	(revision 181135)
+++ b/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp	(working copy)
@@ -181,6 +181,10 @@
     }
   }
 
+  // Dummy custom expansion of stack save/restore
+  setOperationAction(ISD::STACKSAVE, MVT::Other, Custom);
+  setOperationAction(ISD::STACKRESTORE, MVT::Other, Custom);
+
   // Now deduce the information based on the above mentioned
   // actions
   computeRegisterProperties();
@@ -847,6 +851,9 @@
     return LowerSTORE(Op, DAG);
   case ISD::LOAD:
     return LowerLOAD(Op, DAG);
+  case ISD::STACKSAVE:
+  case ISD::STACKRESTORE:
+    return SDValue();
   default:
     llvm_unreachable("Custom lowering not defined for operation");
   }
--- a/llvm/lib/Target/NVPTX/NVPTX.td	(revision 181135)
+++ b/llvm/lib/Target/NVPTX/NVPTX.td	(working copy)
@@ -42,6 +42,18 @@
                              "Use PTX version 3.1">;
 
 //===----------------------------------------------------------------------===//
+// Driver Interfaces.
+// - NVPTX backend can generate PTX code for CUDA or OpenCL programs.
+// - Generated PTX for CUDA and OpenCL programs could be different.
+//===----------------------------------------------------------------------===//
+def NVCL : SubtargetFeature<"drv_nvcl", "DrvInterface", "NVPTX::NVCL",
+                            "Use NVIDIA/OpenCL driver interface">;
+def CUDA : SubtargetFeature<"drv_cuda", "DrvInterface", "NVPTX::CUDA",
+                            "Use CUDA driver interface">;
+def TEST : SubtargetFeature<"drv_test", "DrvInterface", "NVPTX::TEST",
+                            "Use test driver interface">;
+
+//===----------------------------------------------------------------------===//
 // NVPTX supported processors.
 //===----------------------------------------------------------------------===//
 
--- a/llvm/lib/Target/NVPTX/NVPTXSubtarget.h	(revision 181135)
+++ b/llvm/lib/Target/NVPTX/NVPTXSubtarget.h	(working copy)
@@ -27,7 +27,6 @@
 class NVPTXSubtarget : public NVPTXGenSubtargetInfo {
 
   std::string TargetName;
-  NVPTX::DrvInterface drvInterface;
   bool Is64Bit;
 
   // PTX version x.y is represented as 10*x+y, e.g. 3.1 == 31
@@ -36,6 +35,9 @@
   // SM version x.y is represented as 10*x+y, e.g. 3.1 == 31
   unsigned int SmVersion;
 
+  // PTX driver interface
+  unsigned int DrvInterface;
+
 public:
   /// This constructor initializes the data members to match that
   /// of the specified module.
@@ -68,7 +70,7 @@
   bool is64Bit() const { return Is64Bit; }
 
   unsigned int getSmVersion() const { return SmVersion; }
-  NVPTX::DrvInterface getDrvInterface() const { return drvInterface; }
+  unsigned int getDrvInterface() const { return DrvInterface; }
   std::string getTargetName() const { return TargetName; }
 
   unsigned getPTXVersion() const { return PTXVersion; }
--- a/llvm/lib/Target/NVPTX/NVPTX.h	(revision 181135)
+++ b/llvm/lib/Target/NVPTX/NVPTX.h	(working copy)
@@ -69,11 +69,6 @@
 extern Target TheNVPTXTarget64;
 
 namespace NVPTX {
-enum DrvInterface {
-  NVCL,
-  CUDA,
-  TEST
-};
 
 // A field inside TSFlags needs a shift and a mask. The usage is
 // always as follows :
--- a/llvm/test/CodeGen/NVPTX/drv-opencl.ll	(revision 0)
+++ b/llvm/test/CodeGen/NVPTX/drv-opencl.ll	(revision 0)
@@ -0,0 +1,5 @@
+; RUN: llc < %s -march=nvptx -mcpu=sm_20 -mattr=drv_nvcl | FileCheck %s
+; RUN: llc < %s -march=nvptx64 -mcpu=sm_20 -mattr=drv_nvcl | FileCheck %s
+
+
+; CHECK: .target sm_20, texmode_independent
--- a/llvm/test/CodeGen/NVPTX/drv-cuda.ll	(revision 0)
+++ b/llvm/test/CodeGen/NVPTX/drv-cuda.ll	(revision 0)
@@ -0,0 +1,5 @@
+; RUN: llc < %s -march=nvptx -mcpu=sm_20 -mattr=drv_cuda | FileCheck %s
+; RUN: llc < %s -march=nvptx64 -mcpu=sm_20 -mattr=drv_cuda | FileCheck %s
+
+
+; CHECK: .target sm_20
--- a/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp  (revision 181135)
+++ b/llvm/lib/Target/NVPTX/NVPTXSubtarget.cpp  (working copy)
@@ -19,24 +19,11 @@
 
 using namespace llvm;
 
-// Select Driver Interface
-#include "llvm/Support/CommandLine.h"
-namespace {
-cl::opt<NVPTX::DrvInterface> DriverInterface(
-    cl::desc("Choose driver interface:"),
-    cl::values(clEnumValN(NVPTX::NVCL, "drvnvcl", "Nvidia OpenCL driver"),
-               clEnumValN(NVPTX::CUDA, "drvcuda", "Nvidia CUDA driver"),
-               clEnumValN(NVPTX::TEST, "drvtest", "Plain Test"), clEnumValEnd),
-    cl::init(NVPTX::NVCL));
-}
-
 NVPTXSubtarget::NVPTXSubtarget(const std::string &TT, const std::string &CPU,
                                const std::string &FS, bool is64Bit)
     : NVPTXGenSubtargetInfo(TT, CPU, FS), Is64Bit(is64Bit), PTXVersion(0),
-      SmVersion(20) {
+      SmVersion(20), DrvInterface(0) {
 
-  drvInterface = DriverInterface;
-
   // Provide the default CPU if none
   std::string defCPU = "sm_20";
 
@@ -58,4 +45,9 @@
   if (PTXVersion == 0) {
     PTXVersion = 31;
   }
+
+  // Default to NVIDIA/OpenCL driver interface.
+  if (DrvInterface == 0) {
+    DrvInterface = NVPTX::NVCL;
+  }
 }
--- a/llvm/lib/CodeGen/LexicalScopes.cpp	(revision 181135)
+++ b/llvm/lib/CodeGen/LexicalScopes.cpp	(working copy)
@@ -201,7 +201,8 @@
   if (Scope.isLexicalBlock()) {
     DILexicalBlock DB(N);
     DIDescriptor ParentDesc = DB.getContext();
-    Parent = getOrCreateAbstractScope(ParentDesc);
+    if (ParentDesc)
+      Parent = getOrCreateAbstractScope(ParentDesc);
   }
   AScope = new LexicalScope(Parent, DIDescriptor(N), NULL, true);
   AbstractScopeMap[N] = AScope;
--- a/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp	(revision 182420)
+++ b/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp	(working copy)
@@ -12,12 +12,13 @@
 //
 //===----------------------------------------------------------------------===//
 
+#define GET_SUBTARGETINFO_ENUM
 #include "NVPTXAsmPrinter.h"
 #include "MCTargetDesc/NVPTXMCAsmInfo.h"
 #include "NVPTX.h"
 #include "NVPTXInstrInfo.h"
 #include "NVPTXNumRegisters.h"
-#include "NVPTXRegisterInfo.h"
+#include "NVPTXGenSubtargetInfo.inc"
 #include "NVPTXTargetMachine.h"
 #include "NVPTXUtilities.h"
 #include "cl_common_defines.h"
@@ -411,6 +412,15 @@
     emitGlobals(*MF->getFunction()->getParent());
     GlobalsEmitted = true;
   }
+
+  // Emit the global Fake Stack Object
+  const MachineFrameInfo *MFI = MF->getFrameInfo();
+  int NumBytes = (int) MFI->getStackSize();
+  if (NumBytes) {
+    O << ".visible .global .align " << MFI->getMaxAlignment() << " .b8 \t"
+        << DEPOTNAME
+        << getFunctionNumber() << "[" << NumBytes << "];\n\n";
+  }
   
   // Set up
   MRI = &MF->getRegInfo();
@@ -446,6 +456,12 @@
   raw_svector_ostream O(Str);
   emitDemotedVars(MF->getFunction(), O);
   OutStreamer.EmitRawText(O.str());
+
+  // For KernelGen main kernel - emit membar instructions,
+  // to be replaced by control code injection at CUBIN level.
+  if (CurrentFnSym->getName() == "__kernelgen_main")
+    for (int i = 0; i < 6; i++)
+      OutStreamer.EmitRawText(StringRef("\tmembar.sys;\n"));
 }
 
 void NVPTXAsmPrinter::EmitFunctionBodyEnd() {
@@ -1054,6 +1070,8 @@
 void NVPTXAsmPrinter::emitLinkageDirective(const GlobalValue *V,
                                            raw_ostream &O) {
   if (nvptxSubtarget.getDrvInterface() == NVPTX::CUDA) {
+    if (V->hasWeakLinkage() || V->hasLinkOnceLinkage())
+      O << ".weak ";
     if (V->hasExternalLinkage()) {
       if (isa<GlobalVariable>(V)) {
         const GlobalVariable *GVar = cast<GlobalVariable>(V);
@@ -1227,6 +1245,7 @@
     // Ptx allows variable initilization only for constant and global state
     // spaces.
     if (((PTy->getAddressSpace() == llvm::ADDRESS_SPACE_GLOBAL) ||
+         (PTy->getAddressSpace() == llvm::ADDRESS_SPACE_GENERIC) ||
          (PTy->getAddressSpace() == llvm::ADDRESS_SPACE_CONST_NOT_GEN) ||
          (PTy->getAddressSpace() == llvm::ADDRESS_SPACE_CONST)) &&
         GVar->hasInitializer()) {
@@ -1251,6 +1270,7 @@
       // Ptx allows variable initilization only for constant and
       // global state spaces.
       if (((PTy->getAddressSpace() == llvm::ADDRESS_SPACE_GLOBAL) ||
+           (PTy->getAddressSpace() == llvm::ADDRESS_SPACE_GENERIC) ||
            (PTy->getAddressSpace() == llvm::ADDRESS_SPACE_CONST_NOT_GEN) ||
            (PTy->getAddressSpace() == llvm::ADDRESS_SPACE_CONST)) &&
           GVar->hasInitializer()) {
@@ -1319,6 +1339,7 @@
     O << "local";
     break;
   case llvm::ADDRESS_SPACE_GLOBAL:
+  case llvm::ADDRESS_SPACE_GENERIC:
     O << "global";
     break;
   case llvm::ADDRESS_SPACE_CONST:
@@ -1690,8 +1711,6 @@
   const MachineFrameInfo *MFI = MF.getFrameInfo();
   int NumBytes = (int) MFI->getStackSize();
   if (NumBytes) {
-    O << "\t.local .align " << MFI->getMaxAlignment() << " .b8 \t" << DEPOTNAME
-      << getFunctionNumber() << "[" << NumBytes << "];\n";
     if (nvptxSubtarget.is64Bit()) {
       O << "\t.reg .b64 \t%SP;\n";
       O << "\t.reg .b64 \t%SPL;\n";
@@ -1917,16 +1936,14 @@
   case Type::ArrayTyID:
   case Type::VectorTyID:
   case Type::StructTyID: {
-    if (isa<ConstantArray>(CPV) || isa<ConstantVector>(CPV) ||
-        isa<ConstantStruct>(CPV)) {
+    if (isa<ConstantAggregateZero>(CPV))
+      aggBuffer->addZeros(Bytes);
+    else {
       int ElementSize = TD->getTypeAllocSize(CPV->getType());
       bufferAggregateConstant(CPV, aggBuffer);
       if (Bytes > ElementSize)
         aggBuffer->addZeros(Bytes - ElementSize);
-    } else if (isa<ConstantAggregateZero>(CPV))
-      aggBuffer->addZeros(Bytes);
-    else
-      llvm_unreachable("Unexpected Constant type");
+    }
     break;
   }
 
