--- a/llvm/include/llvm/Module.h	2011-07-31 23:06:09.371772843 +0400
+++ b/llvm/include/llvm/Module.h	2011-08-05 00:10:40.010015703 +0400
@@ -29,6 +29,7 @@
 class GVMaterializer;
 class LLVMContext;
 class StructType;
+class ArrayType;
 template<typename T> struct DenseMapInfo;
 template<typename KeyT, typename ValueT, 
          typename KeyInfoT, typename ValueInfoT> class DenseMap;
--- a/llvm/lib/VMCore/Module.cpp	2011-08-05 18:26:54.115445526 +0400
+++ b/llvm/lib/VMCore/Module.cpp	2011-08-05 18:26:43.378675565 +0400
@@ -442,11 +442,15 @@
     DenseSet<Type*> VisitedTypes;
     
     std::vector<StructType*> &StructTypes;
+    
+    const Module* M;
   public:
     TypeFinder(std::vector<StructType*> &structTypes)
       : StructTypes(structTypes) {}
     
     void run(const Module &M) {
+      this->M = &M;
+      
       // Get types from global variables.
       for (Module::const_global_iterator I = M.global_begin(),
            E = M.global_end(); I != E; ++I) {
@@ -506,6 +510,14 @@
       if (StructType *STy = dyn_cast<StructType>(Ty))
         StructTypes.push_back(STy);
       
+      // If type is array, add a name for its container structure.
+      if (ArrayType *ATy = dyn_cast<ArrayType>(Ty))
+      {
+        std::vector<Type*> structMembers;
+        structMembers.push_back(ATy);
+        StructTypes.push_back(StructType::get(M->getContext(), structMembers));
+      }
+      
       // Recursively walk all contained types.
       for (Type::subtype_iterator I = Ty->subtype_begin(),
            E = Ty->subtype_end(); I != E; ++I)
--- a/llvm/lib/Target/CBackend/CBackend.cpp	2011-08-05 18:29:54.734574154 +0400
+++ b/llvm/lib/Target/CBackend/CBackend.cpp	2011-08-05 17:50:55.480804768 +0400
@@ -510,17 +510,17 @@
     if (!IgnoreName)
       return Out << getStructName(STy) << ' ' << NameSoFar;
     
-    Out << NameSoFar + " {\n";
+    Out << "struct " << NameSoFar + " {\n";
     unsigned Idx = 0;
     for (StructType::element_iterator I = STy->element_begin(),
            E = STy->element_end(); I != E; ++I) {
       Out << "  ";
-      printType(Out, *I, false, "field" + utostr(Idx++));
+      printType(Out, *I, false, "field" + utostr(Idx++), (STy->getNumElements() == 1) ? IgnoreName : false);
       Out << ";\n";
     }
     Out << '}';
     if (STy->isPacked())
       Out << " __attribute__ ((packed))";
     return Out;
   }
 
@@ -540,14 +542,24 @@
 
   case Type::ArrayTyID: {
     ArrayType *ATy = cast<ArrayType>(Ty);
+
+    // Check to see if the type is named.
+    if (!IgnoreName)
+    {
+      std::vector<Type*> structMembers;
+      structMembers.push_back(ATy);      
+      return Out << getStructName(StructType::get(
+        TheModule->getContext(), structMembers)) << ' ' << NameSoFar;
+    }
+    
     unsigned NumElements = ATy->getNumElements();
     if (NumElements == 0) NumElements = 1;
     // Arrays are wrapped in structs to allow them to have normal
     // value semantics (avoiding the array "decay").
-    Out << NameSoFar << " { ";
+    //Out << "struct { ";
     printType(Out, ATy->getElementType(), false,
               "array[" + utostr(NumElements) + "]");
-    return Out << "; }";
+    return Out; // << "; } " << NameSoFar;
   }
 
   default:
@@ -2043,12 +2119,12 @@
 
   if (StructTypes.empty()) return;
 
+  // Print out forward declarations for structure types before anything else!
   Out << "/* Structure forward decls */\n";
 
   unsigned NextTypeID = 0;
   
   // If any of them are missing names, add a unique ID to UnnamedStructIDs.
-  // Print out forward declarations for structure types.
   for (unsigned i = 0, e = StructTypes.size(); i != e; ++i) {
     StructType *ST = StructTypes[i];
 
@@ -2057,6 +2133,20 @@
 
     std::string Name = getStructName(ST);
 
+    Out << "struct " << Name << ";\n";
+  }
+
+  Out << '\n';
+  
+  // Now we can print out typedefs.  Above, we guaranteed that this can only be
+  // for struct or opaque types.
+  Out << "/* Typedefs */\n";
+
+  for (unsigned i = 0, e = StructTypes.size(); i != e; ++i) {
+    StructType *ST = StructTypes[i];
+
+    std::string Name = getStructName(ST);
+
     Out << "typedef struct " << Name << ' ' << Name << ";\n";
   }
 
@@ -2086,6 +2176,29 @@
   if (Ty->isPointerTy() || Ty->isPrimitiveType() || Ty->isIntegerTy())
     return;
 
+  // Walk through arrays, declaring their container structs.
+  if (Ty->isArrayTy())
+  {
+    ArrayType *ATy = cast<ArrayType>(Ty);
+    std::vector<Type*> structMembers;
+    structMembers.push_back(ATy);
+
+    StructType* ST = StructType::get(
+        TheModule->getContext(), structMembers);
+    
+    // Check to see if we have already printed this struct.
+    if (!StructPrinted.insert(ST)) return;
+    
+  // Print all contained types first.
+  for (Type::subtype_iterator I = Ty->subtype_begin(),
+       E = Ty->subtype_end(); I != E; ++I)
+    printContainedStructs(*I, StructPrinted);
+    
+    // Print structure type out.
+    printType(Out, ST, false, getStructName(ST), true);
+    Out << ";\n\n";
+  }
+  
   // Print all contained types first.
   for (Type::subtype_iterator I = Ty->subtype_begin(),
        E = Ty->subtype_end(); I != E; ++I)
